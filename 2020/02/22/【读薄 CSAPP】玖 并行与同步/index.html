<!DOCTYPE html><html lang="null"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Bean's blog"><meta name="keywords" content="xbean1028,software"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>【读薄 CSAPP】玖 并行与同步 | Bean Panda</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【读薄 CSAPP】玖 并行与同步</h1><a id="logo" href="/.">Bean Panda</a><p class="description">软件小白，江山点墨</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Suche"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">【读薄 CSAPP】玖 并行与同步</h1><div class="post-meta"><a href="/2020/02/22/【读薄 CSAPP】玖 并行与同步/#comments" class="comment-count"></a><p><span class="date">Feb 22, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Schlägt</i></i></span></p></div><div class="post-content"><h1 id="【读薄-CSAPP】玖-并行与同步"><a href="#【读薄-CSAPP】玖-并行与同步" class="headerlink" title="【读薄 CSAPP】玖 并行与同步"></a>【读薄 CSAPP】玖 并行与同步</h1><p>进程和线程有什么差别？超线程又是什么意思？为什么多线程能够提高程序执行的速度？是所有情况都适用吗？并行程序有没有什么限制？这一讲我们来聊聊并行与同步这两个『继往开来』的概念。在今后的学习中，大家一定会不止一次发现，很多问题说来说去，其实就是并行与同步的问题。<br>@[toc]</p>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>理解并行的几个层次：进程、事件、线程</li>
<li>了解 Posix 标准</li>
<li>了解同步问题产生的背景，以及信号量的工作机制</li>
<li>了解『生产者-消费者问题』和『读者-写者问题』</li>
<li>理解线程安全和一致性问题</li>
</ol>
<h2 id="并行方法"><a href="#并行方法" class="headerlink" title="并行方法"></a>并行方法</h2><p>首先一定要清楚地意识到：『并行编程不简单』！最主要的原因恐怕就是我们自己的大脑，人脑实际上是一个非常精妙的系统，所采取的并行策略是一明一暗两条线，但是对于明线来说，是线性的，于是就和计算机中并行的概念冲突了。另外时间这个概念也是线性的，这就导致了想要处理好并行程序可能出现的各种问题几乎是不可能的（或者常常要出错）。</p>
<p>常见的错误有仨：竞争条件[2]、死锁[3]和活锁[4]，尤其是在现在的多核处理器架构中，更容易出现这类并行问题。</p>
<p>我们前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93ZHh0dWIuY29tL2ltYWdlcy8xNDYyMDIwMTcxNDMyNy5qcGc?x-oss-process=image/format,png" alt="img"></p>
<p>这里具体讲解一下：Client 1 向 Server 发送连接请求(connect)，Server 接受(accept)之后开始等待 Client 1 发送请求（也就是开始 read），这之后 Client 1 发送具体的内容(write)后转为等待响应(call read)，Server 的 read 接收到了内容之后，发送响应(write) 后仅需进入等待(read)，而 Client 1 接收到了响应(ret read)，最后根据用户指令退出(close)。</p>
<p>而只有当 Client 1 断开之后，Server 才会处理 Client 2 的请求，从图中也可以看到这一点。具体是在哪里等待呢？因为 TCP 会缓存，所以实际上 Client 2 在 <code>ret read</code> 之前进行等待，为了解决这个问题，我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<p>总体来说，根据系统机制的层级和实现方式，有下面三大类方法：</p>
<ol>
<li>基于进程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）</li>
</ul>
</li>
<li>基于事件<ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
</li>
<li>基于线程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
<li>属于基于进程和基于事件的混合体</li>
</ul>
</li>
</ol>
<h3 id="基于进程"><a href="#基于进程" class="headerlink" title="基于进程"></a>基于进程</h3><p>为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。</p>
<p>具体的代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)&#123;</span><br><span class="line">    while (waitpid(-1, 0, WNOHANG) &gt; 0)</span><br><span class="line">        ;</span><br><span class="line">    return;</span><br><span class="line">    // Reap all zombie children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        if (Fork() == 0) &#123;</span><br><span class="line">            Close(listenfd); // Child closes its listening socket</span><br><span class="line">            echo(connfd); // Child services client</span><br><span class="line">            Close(connfd); // Child closes connection with client</span><br><span class="line">            exit(0); // Child exits</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); // Parent closes connected socket (important!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用文字描述一下流程：首先，服务器在 <code>accept</code> 函数中（对应 <code>listenfd</code>）等待连接请求，然后客户端通过调用 <code>connect</code> 函数发送连接请求，最后服务器在 <code>accept</code> 中返回 <code>connfd</code> 并且 fork 一个子进程来处理客户端连接，连接建立在 <code>listenfd</code> 和 <code>connfd</code> 间。</p>
<p>整个执行模型中：</p>
<ul>
<li><p>每个客户端由独立子进程处理</p>
<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li><p>不同进程之间不共享数据</p>
</li>
<li><p>父进程和子进程都有 <code>listenfd</code>和<code>connfd</code>，所以在父进程中需要关闭 <code>connfd</code>，在子进程中需要关闭<code>listenfd</code></p>
<ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 <code>refcnt(connfd) = 2</code>，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
</li>
</ul>
<p>基于进程的方式可以并行处理连接，除了共享已打开的 file table 外，无论是 descriptor 还是全局变量都不共享，不大容易造成同步问题，比较简单粗暴。但是带来了额外的进程管理开销，并且进程间通讯不便，需要使用 IPC (interprocess communication)。</p>
<h3 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h3><p>服务器会维护一个 connection 数组，包含若干 <code>connfd</code>，每个输入请求都被当做事件，然后每次从已有的事件中选取一个进行处理。</p>
<p>基于实践的好处在于只使用一个逻辑控制流和地址空间，可以利用调试器进行单步调试（其他的方法因为并行的缘故基本没办法调试），也不会有进程/线程控制的开销。但是相比之下，代码的逻辑复杂度会比较高，很难进行精细度比较高的并行，也无法发挥多核处理器的全部性能。</p>
<h3 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h3><p>和基于进程的方法非常相似，唯一的区别是这里用线程。进程其实是比较『重』的，一个进程包括进程上下文、代码、数据和栈。如果从线程的角度来描述，一个进程则包括线程、代码、数据和上下文。也就是说，线程作为单独可执行的部分，被抽离出来了，一个进程可以有多个线程。</p>
<p>每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。</p>
<p>和进程不同的是，线程没有一个明确的树状结构（使用 <code>fork</code> 是有明确父进程子进程区分的）。和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的。</p>
<p>进程和线程的差别已经被说了太多次，这里简单提一下。相同点在于，它们都有自己的逻辑控制流，可以并行，都需要进行上下文切换。不同点在于，线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）</p>
<p><strong>POSIX Threads</strong></p>
<p>Pthreads 是一个线程库，基本上只要是 C 程序能跑的平台，都会支持这个标准。Pthreads定义了一套C语言的类型、函数与常量，它以 <code>pthread.h</code> 头文件和一个线程库实现。</p>
<p>Pthreads API 中大致共有 100 个函数调用，全都以 <code>pthread_</code> 开头，并可以分为四类：</p>
<ol>
<li>线程管理，例如创建线程，等待(join)线程，查询线程状态等。</li>
<li>Mutex：创建、摧毁、锁定、解锁、设置属性等操作</li>
<li>条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作</li>
<li>使用了读写锁的线程间的同步管理</li>
</ol>
<p>POSIX 的 Semaphore API 可以和 Pthreads 协同工作，但这并不是 Pthreads 的标准。因而这部分API是以 <code>sem_</code> 打头，而非 <code>pthread_</code>。</p>
<p>我们用线程的方式重写一次之前的 Echo Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Thread routine</span><br><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    int connf = *((int *)vargp);</span><br><span class="line">    // detach 之后不用显式 join，会在执行完毕后自动回收</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    // 一定要记得关闭！</span><br><span class="line">    Close(connfd);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, *connfdp;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        // 这里使用新分配的 connected descriptor 来避免竞争条件</span><br><span class="line">        connfdp = Malloc(sizeof(int));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, NULL, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个模型中，每个客户端由单独的线程进行处理，这些线程除了线程 id 之外，共享所有的进程状态（但是每个线程有自己的局部变量栈）。</p>
<p>使用线程并行，能够在不同的线程见方便地共享数据，效率也比进程高，但是共享变量可能会造成比较难发现的程序问题，很难调试和测试。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里简单归纳下三种并行方法的特点：</p>
<ul>
<li>基于进程<ul>
<li>难以共享资源，但同时也避免了可能带来的共享问题</li>
<li>添加/移除进程开销较大</li>
</ul>
</li>
<li>基于事件<ul>
<li>非常底层的实现机制</li>
<li>使用全局控制而非调度</li>
<li>开销比较小</li>
<li>但是无法提供精细度较高的并行</li>
<li>无法充分利用多核处理器</li>
</ul>
</li>
<li>基于线程<ul>
<li>容易共享资源，但也容易出现问题</li>
<li>开销比进程小</li>
<li>对于具体的调度可控性较低</li>
<li>难以调试（因为事件发生的顺序不一致）</li>
</ul>
</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>在介绍同步之前，我们需要弄清楚一个定义，什么是 Shared variable（共享变量）？</p>
<blockquote>
<p>A variable <code>x</code> is <em>shared</em> if and only if multiple threads reference some instance of <code>x</code></p>
</blockquote>
<p>另外一个需要注意的是线程的内存模型，因为概念上的模型和实际的模型有一些差异，非常容易导致错误。</p>
<p>在概念上的模型中：</p>
<ul>
<li>多个线程在一个单独进程的上下文中运行</li>
<li>每个线程有单独的线程上下文（线程 ID，栈，栈指针，PC，条件码，GP 寄存器）</li>
<li>所有的线程共享剩下的进程上下文<ul>
<li>Code, data, heap, and shared library segments of the process virtual address space</li>
<li>Open files and installed handlers</li>
</ul>
</li>
</ul>
<p>在实际的模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">char **ptr; // 全局变量</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    char *msgs[2] = &#123;</span><br><span class="line">        &quot;Good Day!&quot;,</span><br><span class="line">        &quot;Bad Day!&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptr = msgs;</span><br><span class="line">for (i = 0; i &lt; 2; i++)</span><br><span class="line">    Pthread_create(&amp;tid, NULL, thread, (void *)i);</span><br><span class="line">Pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    long myid = (long)vargp;</span><br><span class="line">    static int cnt = 0;</span><br><span class="line">    </span><br><span class="line">    // 这里每个线程都可以访问 ptr 这个全局变量</span><br><span class="line">    printf(&quot;[%ld]: %s (cnt=%d)\n&quot;, myid, ptr[myid], ++cnt);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个不同类型的变量，我们一一来看一下：</p>
<ul>
<li>全局变量：在函数外声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
<li>局部变量：在函数内声明，且没有用 static 关键字<ul>
<li>每个线程的栈中都保存着对应线程的局部变量</li>
</ul>
</li>
<li>局部静态变量：在函数内用 static 关键字声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
</ul>
<p>具体来分析下，一个变量只有在被多个线程引用的时候才算是共享，在这个例子中，共享变量有 <code>ptr</code>, <code>cnt</code> 和 <code>msgs</code>；非共享变量有 <code>i</code> 和 <code>myid</code>。</p>
<h3 id="关键区域-Critical-Section"><a href="#关键区域-Critical-Section" class="headerlink" title="关键区域 Critical Section"></a>关键区域 Critical Section</h3><p>这一部分我们用一个具体的例子来进行讲解，看看如何用多个线程来计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 全局共享变量</span><br><span class="line">volatile long cnt = 0; // 计数器</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    long niters;</span><br><span class="line">    pthread_t tid1, tid2;</span><br><span class="line">    </span><br><span class="line">    niter2 = atoi(argv[1]);</span><br><span class="line">    Pthread_create(&amp;tid1, NULL, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, NULL, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, NULL);</span><br><span class="line">    Pthread_join(tid2, NULL);</span><br><span class="line">    </span><br><span class="line">    // 检查结果</span><br><span class="line">    if (cnt != (2 * niters))</span><br><span class="line">        printf(&quot;Wrong! cnt=%ld\n&quot;, cnt);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Correct! cnt=%ld\n&quot;, cnt);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后发现不是每次都出现同样的结果，我们把操作 <code>cnt</code> 的部分抽出来单独看一看：</p>
<p>线程中循环部分的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; niters; i++)</span><br><span class="line">    cnt++;</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    # 以下四句为 Head 部分，记为 H</span><br><span class="line">    movq    (%rdi), %rcx</span><br><span class="line">    testq   %rcx, %rcx</span><br><span class="line">    jle     .L2</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">.L3:</span><br><span class="line">    movq    cnt(%rip), %rdx # 载入 cnt，记为 L</span><br><span class="line">    addq    $1, %rdx        # 更新 cnt，记为 U</span><br><span class="line">    movq    %rdx, cnt(%rip) # 保存 cnt，记为 S</span><br><span class="line">    # 以下为 Tail 部分，记为 T</span><br><span class="line">    addq    $1, %rax</span><br><span class="line">    cmpq    %rcx, %rax</span><br><span class="line">    jne     .L3</span><br><span class="line">.L2:</span><br></pre></td></tr></table></figure>

<p>这里有一点需要注意，<code>cnt</code> 使用了 <code>volatile</code> 关键字声明，意思是不要在寄存器中保存值，无论是读取还是写入，都要对内存操作（还记得 write-through 吗？）。这里把具体的步骤分成 5 步：HLUST，尤其要注意 LUS 这三个操作，这三个操作必须在一次执行中完成，一旦次序打乱，就会出现问题，不同线程拿到的值就不一定是最新的。</p>
<p>更多相关内容，可以参考<a href="http://wdxtub.com/vault/csapp-23.html" target="_blank" rel="noopener">Synchronization - Basics</a>，其中提到了利用图表来描述关键区域的方法，感兴趣可以看一下。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>针对关键区域的问题，我们可以考虑用信号量来限制程序的执行顺序。计数信号量具备两种操作动作，称为 V（又称signal()）与 P（wait()）。 V 操作会增加信号量 S 的数值，P 操作会减少。运作方式：</p>
<ol>
<li>初始化，给与它一个非负数的整数值。</li>
<li>运行 P，信号量 S 的值将被减少。企图进入临界区块的进程，需要先运行 P。当信号量 S 减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。</li>
<li>运行 V，信号量 S 的值会被增加。结束离开临界区块的进程，将会运行 V。当信号量 S 不为负值时，先前被挡住的其他进程，将可获准进入临界区块。</li>
</ol>
<p>我们来看看如何修改可以使得前面我们的计数程序正确运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 先定义信号量</span><br><span class="line">volatile long cnt = 0;</span><br><span class="line">sem_t mutex;</span><br><span class="line"></span><br><span class="line">Sem_init(&amp;mutex, 0, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在线程中用 P 和 V 包围关键操作</span><br><span class="line">for (i = 0; i &lt; niters; i++)</span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用线程时，脑中需要有一个清晰的分享变量的概念，共享变量需要互斥访问，而 Semaphores 是一个基础的机制。</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93ZHh0dWIuY29tL2ltYWdlcy8xNDYyMDI1MTA4MDczOC5qcGc?x-oss-process=image/format,png" alt="img"></p>
<p>具体的同步模型为：</p>
<ul>
<li>生产者等待空的 slot，把 item 存储到 buffer，并通知消费者</li>
<li>消费整等待 item，从 buffer 中移除 item，并通知生产者</li>
</ul>
<p>主要用于</p>
<ul>
<li>多媒体处理<ul>
<li>生产者生成 MPEG 视频帧，消费者进行渲染</li>
</ul>
</li>
<li>事件驱动的图形用户界面<ul>
<li>生产者检测到鼠标点击、移动和键盘输入，并把对应的事件插入到 buffer 中</li>
<li>消费者从 buffer 中获取事件，并绘制到到屏幕上</li>
</ul>
</li>
</ul>
<p>接下来我们实现一个有 n 个元素 buffer，为此，我们需要一个 mutex 和两个用来计数的 semaphore：</p>
<ul>
<li><code>mutex</code>: 用来保证对 buffer 的互斥访问</li>
<li><code>slots</code>: 统计 buffer 中可用的 slot 数目</li>
<li><code>items</code>: 统计 buffer 中可用的 item 数目</li>
</ul>
<p>我们直接来看代码，就比较清晰了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 头文件 sbuf.h</span><br><span class="line">// 包括几个基本操作</span><br><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int *buf;    // Buffer array</span><br><span class="line">    int n;       // Maximum number of slots</span><br><span class="line">    int front;   // buf[(front+1)%n] is first item</span><br><span class="line">    int rear;    // buf[rear%n] is the last item</span><br><span class="line">    sem_t mutex; // Protects accesses to buf</span><br><span class="line">    sem_t slots; // Counts available slots</span><br><span class="line">    sem_t items; // Counts available items</span><br><span class="line">&#125; sbuf_t;</span><br><span class="line"></span><br><span class="line">void sbuf_init(sbuf_t *sp, int n);</span><br><span class="line">void sbuf_deinit(sbuf_t *sp);</span><br><span class="line">void sbuf_insert(sbuf_t *sp, int item);</span><br><span class="line">int sbuf_remove(sbuf_t *sp);</span><br></pre></td></tr></table></figure>

<p>然后是具体的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// sbuf.c</span><br><span class="line"></span><br><span class="line">// Create an empty, bounded, shared FIFO buffer with n slots</span><br><span class="line">void sbuf_init(sbuf_t *sp, int n) &#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, sizeof(int));</span><br><span class="line">    sp-&gt;n = n;                  // Buffer holds max of n items</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = 0;   // Empty buffer iff front == rear</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, 0, 1); // Binary semaphore for locking</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, 0, n); // Initially, buf has n empty slots</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, 0, 0); // Initially, buf has 0 items</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Clean up buffer sp</span><br><span class="line">void sbuf_deinit(sbuf_t *sp)&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Insert item onto the rear of shared buffer sp</span><br><span class="line">void sbuf_insert(sbuf_t *sp, int item) &#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                        // Wait for available slot</span><br><span class="line">    P(&amp;sp-&gt;mutext);                       // Lock the buffer</span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item; // Insert the item</span><br><span class="line">    V(&amp;sp-&gt;mutex);                        // Unlock the buffer</span><br><span class="line">    V(&amp;sp-&gt;items);                        // Announce available item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Remove and return the first tiem from the buffer sp</span><br><span class="line">int sbuf_remove(sbuf_f *sp) &#123;</span><br><span class="line">    int item;</span><br><span class="line">    P(&amp;sp-&gt;items);                         // Wait for available item</span><br><span class="line">    P(&amp;sp-&gt;mutex);                         // Lock the buffer</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)]; // Remove the item</span><br><span class="line">    V(&amp;sp-&gt;mutex);                         // Unlock the buffer</span><br><span class="line">    V(&amp;sp-&gt;slots);                         // Announce available slot</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>是互斥问题的通用描述，具体为：</p>
<ul>
<li>读者线程只读取对象</li>
<li>写者线程修改对象</li>
<li>写者对于对象的访问是互斥的</li>
<li>多个读者可以同时读取对象</li>
</ul>
<p>常见的应用场景是：</p>
<ul>
<li>在线订票系统</li>
<li>多线程缓存 web 代理</li>
</ul>
<p>根据不同的读写策略，又两类读者写者问题，需要注意的是，这两种情况都可能出现 starvation。</p>
<blockquote>
<p>第一类读者写者问题（读者优先）</p>
</blockquote>
<ul>
<li>如果写者没有获取到使用对象的权限，不应该让读者等待</li>
<li>在等待的写者之后到来的读者应该在写者之前处理</li>
<li>也就是说，只有没有读者的情况下，写者才能工作</li>
</ul>
<blockquote>
<p>第二类读者写者问题（写者优先）</p>
</blockquote>
<ul>
<li>一旦写者可以处理的时候，就不应该进行等待</li>
<li>在等待的写者之后到来的读者应该在写者之后处理</li>
</ul>
<p>具体的代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">sbuf_t sbuf; // Shared buffer of connected descriptors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int byte_cnt;  // Byte counter</span><br><span class="line">static sem_t mutex;   // and the mutex that protects it</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void echo_cnt(int connfd)&#123;</span><br><span class="line">    int n;</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    rio_t rio;</span><br><span class="line">    static pthread_once_t once = PTHREAD_ONCE_INIT;</span><br><span class="line">    </span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        printf(&quot;thread %d received %d (%d total) bytes on fd %d\n&quot;,</span><br><span class="line">                    (int) pthread_self(), n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void init_echo_cnt(void)&#123;</span><br><span class="line">    Sem_init(&amp;mutex, 0, 1);</span><br><span class="line">    byte_cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int connfd = sbuf_remove(&amp;sbuf); // Remove connfd from buf</span><br><span class="line">        echo_cnt(connfd);                // Service client</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int i, listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    for (i = 0; i &lt; NTHREADS; i++) // Create worker threads</span><br><span class="line">        Pthread_create(&amp;tid, NULL, thread, NULL);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); // Insert connfd in buffer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在线程中调用的函数必须是线程安全的，定义为：</p>
<blockquote>
<p>A function is thread-safe iff it will always produce correct results when called repeatedly from multiple concurrent threads</p>
</blockquote>
<p>主要有 4 类线程不安全的函数</p>
<ol>
<li>不保护共享变量的函数<ul>
<li>解决办法：使用 P 和 V semaphore 操作</li>
<li>问题：同步操作会影响性能</li>
</ul>
</li>
<li>在多次调用间保存状态的函数<ul>
<li>解决办法：把状态当做传入参数</li>
</ul>
</li>
<li>返回指向静态变量的指针的函数<ul>
<li>解决办法1：重写函数，传地址用以保存</li>
<li>解决办法2：上锁，并且进行复制</li>
</ul>
</li>
<li>调用线程不安全函数的函数<ul>
<li>解决办法：只调用线程安全的函数</li>
</ul>
</li>
</ol>
<p>另一个重要的概念是 Reentrant Function，定义为：</p>
<blockquote>
<p>A function is <strong>reentrant</strong> iff it accesses no shared variables when called by multiple threads</p>
</blockquote>
<p>Reentrant Functions 是线程安全函数非常重要的子集，不需要同步操作，对于第二类的函数来说（上面提到的），唯一的办法就是把他们修改成 reentrant 的。</p>
<p>标准 C 库中的函数都是线程安全的（如 <code>malloc</code>, <code>free</code>, <code>printf</code>, <code>scanf</code>），大多数 Unix 的系统调用也都是线程安全的。</p>
<p>总结来看，并行编程需要注意的是：</p>
<ul>
<li>要有并行策略，可以把一个大任务分成若干个独立的子任务，或者用分而治之的方式来解决</li>
<li>内循环最好不要有任何同步机制</li>
<li>注意 Amdahl’s Law</li>
<li>一致性是个大问题，无论是计算一致性还是存储一致性，都需要仔细考虑</li>
</ul>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>回想一下，我们之前是如何处理 I/O 的延迟的呢？一个办法是每个客户端都由一个线程来处理，这样就不需要互相等待。现在的多核/超线程处理器提供了另外一种可能。我们不但可以并行执行多个线程，更好的是这些都是自动进行的，当然，我们也可以通过把大任务分成小任务来加速运算。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93ZHh0dWIuY29tL2ltYWdlcy8xNDYyMDMyNzA3MzgxNi5qcGc?x-oss-process=image/format,png" alt="img"></p>
<p>上图是典型的多核处理器架构，这里需要注意的是 L3 缓存（图上没有显示）和主内存都是共享的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲是本系列的最后一部分了，我们首先学习了并行的几个层次：进程、事件、线程，并了解 Posix 标准。在此基础上，针对并行编程可能产生的同步问题，使用信号量给出了简单的解决办法。之后通过『生产者-消费者问题』和『读者-写者问题』对并行和同步进行更加深入的探讨，最后介绍了线程安全和一致性问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/并行计算" target="_blank" rel="noopener">并行计算</a></li>
<li><a href="https://zh.wikipedia.org/wiki/競爭危害" target="_blank" rel="noopener">竞争条件</a></li>
<li><a href="https://zh.wikipedia.org/wiki/死锁" target="_blank" rel="noopener">死锁</a></li>
<li><a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">Deadlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/POSIX_Threads" target="_blank" rel="noopener">Posix Thread</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html" target="_blank" rel="noopener">POSIX thread (pthread) libraries</a></li>
</ol>
<h2 id="特别致谢"><a href="#特别致谢" class="headerlink" title="特别致谢"></a>特别致谢</h2><p>致谢：wdxtub<br>链接：<a href="http://wdxtub.com/csapp/thin-csapp-9/2016/04/16/" target="_blank" rel="noopener">http://wdxtub.com/csapp/thin-csapp-9/2016/04/16/</a></p>
</div><div class="post-copyright"><blockquote><p>Ursprünglicher Autor: Bean</p><p>Ursprünglicher Link: <a href="http://yoursite.com/2020/02/22/【读薄 CSAPP】玖 并行与同步/">http://yoursite.com/2020/02/22/【读薄 CSAPP】玖 并行与同步/</a></p><p>Copyright-Erklärung: Bitte geben Sie die Quelle des Nachdrucks an.</p></blockquote></div><div class="tags"><a href="/tags/CSAPP/">CSAPP</a></div><div class="post-share"><div class="social-share"><span>Aktie:</span></div></div><div class="post-nav"><a href="/2020/02/22/【读薄 CSAPP】捌 网络编程/" class="next">【读薄 CSAPP】捌 网络编程</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#【读薄-CSAPP】玖-并行与同步"><span class="toc-text">【读薄 CSAPP】玖 并行与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#学习目标"><span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行方法"><span class="toc-text">并行方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于进程"><span class="toc-text">基于进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于事件"><span class="toc-text">基于事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于线程"><span class="toc-text">基于线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步"><span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享变量"><span class="toc-text">共享变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键区域-Critical-Section"><span class="toc-text">关键区域 Critical Section</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者-消费者问题"><span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读者-写者问题"><span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全"><span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#超线程"><span class="toc-text">超线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特别致谢"><span class="toc-text">特别致谢</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/22/【读薄 CSAPP】玖 并行与同步/">【读薄 CSAPP】玖 并行与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/22/【读薄 CSAPP】捌 网络编程/">【读薄 CSAPP】捌 网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/21/【读薄 CSAPP】柒 虚拟内存与动态内存分配/">【读薄 CSAPP】柒 虚拟内存与动态内存分配</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/20/【读薄 CSAPP】陆 系统输入输出/">【读薄 CSAPP】陆 系统输入输出</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/19/【读薄 CSAPP】伍 异常控制流/">【读薄 CSAPP】伍 异常控制流</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/18/服务器+宝塔+Chevereto 搭建个人图床/">服务器+宝塔+Chevereto 搭建个人图床</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/18/【读薄 CSAPP】肆 链接/">【读薄 CSAPP】肆 链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/17/【读薄 CSAPP】叁 内存与缓存/">【读薄 CSAPP】叁 内存与缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/【读薄 CSAPP】贰 机器指令与程序优化/">【读薄 CSAPP】贰 机器指令与程序优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/【读薄 CSAPP】壹 数据表示/">【读薄 CSAPP】壹 数据表示</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/物联网/" style="font-size: 15px;">物联网</a> <a href="/tags/计算机视觉及测距/" style="font-size: 15px;">计算机视觉及测距</a> <a href="/tags/ubuntu/" style="font-size: 15px;">ubuntu</a> <a href="/tags/opencv/" style="font-size: 15px;">opencv</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="https://blog.csdn.net/xbean1028/" title="CSDN" target="_blank">CSDN</a><ul></ul><a href="https://github.com/Xbean1028/" title="github" target="_blank">github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Sitemap</a> |  <a href="/atom.xml">Abonnieren Sie diese Site</a> |  <a href="/about/">Kontaktieren Sie den Blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Bean.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>